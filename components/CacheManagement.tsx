import React, { useState, useEffect } from 'react';
import { useRealtimeUpdates } from '@/hooks/useRealtimeUpdates';
import styles from './CacheManagement.module.css';

interface CacheStats {
  memory: {
    size: number;
    calculatedSize: number;
    hits: number;
    misses: number;
  };
  redis: {
    connected: boolean;
    keyCount: number;
    memoryUsage: number;
  };
}

export const CacheManagement: React.FC = () => {
  const [stats, setStats] = useState<CacheStats | null>(null);
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const { isConnected, lastUpdate, clearCache } = useRealtimeUpdates();

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥çµ±è¨ˆã‚’å–å¾—
  const fetchStats = async () => {
    try {
      const response = await fetch('/api/cache-status');
      if (response.ok) {
        const data = await response.json();
        setStats(data);
      }
    } catch (error) {
      console.error('Failed to fetch cache stats:', error);
    }
  };

  useEffect(() => {
    fetchStats();
    // 30ç§’ã”ã¨ã«çµ±è¨ˆã‚’æ›´æ–°
    const interval = setInterval(fetchStats, 30000);
    return () => clearInterval(interval);
  }, []);

  // ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  const getAuthToken = () => {
    let token = process.env.NEXT_PUBLIC_CACHE_CLEAR_TOKEN;
    if (!token) {
      token = localStorage.getItem('cache_clear_token') || '';
      if (!token) {
        token = prompt('ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:') || '';
        if (token) {
          localStorage.setItem('cache_clear_token', token);
        }
      }
    }
    return token;
  };

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ï¼ˆã‚¿ã‚¤ãƒ—åˆ¥ï¼‰
  const handleClearCache = async (type: string) => {
    console.log(`[CacheManagement] Clearing cache with type: ${type}`);
    setLoading(true);
    setMessage('');

    try {
      const token = getAuthToken();
      console.log('[CacheManagement] Token obtained:', token ? 'Yes' : 'No');
      
      const requestBody = { type };
      console.log('[CacheManagement] Sending request:', requestBody);
      
      const response = await fetch('/api/cache-clear', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(requestBody),
      });

      console.log('[CacheManagement] Response status:', response.status);
      const data = await response.json();
      console.log('[CacheManagement] Response data:', data);

      if (response.ok) {
        setMessage(`âœ… ${data.message}`);
        
        // Log cache stats if available
        if (data.stats) {
          console.log('[CacheManagement] Cache stats comparison:', {
            memory: {
              before: data.stats.before.memory.size,
              after: data.stats.after.memory.size,
              cleared: data.stats.before.memory.size - data.stats.after.memory.size
            },
            redis: {
              before: data.stats.before.redis.keyCount,
              after: data.stats.after.redis.keyCount,
              cleared: data.stats.before.redis.keyCount - data.stats.after.redis.keyCount
            }
          });
        }
        
        // Also clear Service Worker cache if clearing all
        if (type === 'all') {
          console.log('[CacheManagement] Clearing Service Worker cache...');
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            const messageChannel = new MessageChannel();
            messageChannel.port1.onmessage = (event) => {
              console.log('[CacheManagement] Service Worker cache cleared:', event.data);
            };
            navigator.serviceWorker.controller.postMessage(
              { type: 'CLEAR_CACHE' },
              [messageChannel.port2]
            );
          }
          
          // Also clear browser caches
          if ('caches' in window) {
            try {
              const cacheNames = await caches.keys();
              console.log('[CacheManagement] Found browser caches:', cacheNames);
              await Promise.all(
                cacheNames.map(cacheName => {
                  console.log(`[CacheManagement] Deleting cache: ${cacheName}`);
                  return caches.delete(cacheName);
                })
              );
              console.log('[CacheManagement] Browser caches cleared');
            } catch (error) {
              console.error('[CacheManagement] Failed to clear browser caches:', error);
            }
          }
        }
        
        // çµ±è¨ˆã‚’æ›´æ–°
        console.log('[CacheManagement] Updating stats in 1 second...');
        setTimeout(() => {
          console.log('[CacheManagement] Fetching updated stats...');
          fetchStats();
        }, 1000);
      } else {
        console.error('[CacheManagement] Error response:', data);
        setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${data.error}`);
      }
    } catch (error) {
      console.error('[CacheManagement] Request failed:', error);
      setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã¨ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ã‚’ä¸€é€£ã®æµã‚Œã§å®Ÿè¡Œ
  const handleClearAndWarmup = async () => {
    setLoading(true);
    setMessage('');

    try {
      const token = getAuthToken();
      
      // 1. ã¾ãšç¾åœ¨ã®ãƒšãƒ¼ã‚¸ãƒªã‚¹ãƒˆã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚‹é–“ã«ï¼‰
      console.log('[CacheManagement] Step 1: Getting page list before cache clear...');
      const pagesResponse = await fetch('/api/cache-get-pages');
      
      let pageIds: string[] = [];
      if (pagesResponse.ok) {
        const pagesData = await pagesResponse.json();
        pageIds = pagesData.pageIds || [];
        console.log(`[CacheManagement] Retrieved ${pageIds.length} page IDs`);
        setMessage(`ğŸ“„ ${pageIds.length}ãƒšãƒ¼ã‚¸ã®IDã‚’å–å¾—ã—ã¾ã—ãŸ`);
      } else {
        console.log('[CacheManagement] Failed to get page list');
        setMessage('âš ï¸ ãƒšãƒ¼ã‚¸ãƒªã‚¹ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
      
      // 2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      console.log('[CacheManagement] Step 2: Clearing cache...');
      const clearResponse = await fetch('/api/cache-clear', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ type: 'all' }),
      });

      if (!clearResponse.ok) {
        const clearData = await clearResponse.json();
        throw new Error(`Cache clear failed: ${clearData.error}`);
      }
      
      setMessage('ğŸ—‘ï¸ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
      
      // 3. å°‘ã—å¾…ã¤
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // 4. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
      console.log('[CacheManagement] Step 3: Warming up cache...');
      const warmupRequestBody = {
        pageIds: pageIds.length > 0 ? pageIds : undefined,
        skipSiteMap: true // ã‚¯ãƒªã‚¢å¾Œãªã®ã§ã‚µã‚¤ãƒˆãƒãƒƒãƒ—ã¯ã‚¹ã‚­ãƒƒãƒ—
      };
      console.log('[CacheManagement] Warmup request body:', {
        hasPageIds: !!warmupRequestBody.pageIds,
        pageIdsCount: warmupRequestBody.pageIds?.length || 0,
        skipSiteMap: warmupRequestBody.skipSiteMap
      });
      
      const warmupResponse = await fetch('/api/cache-warmup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(warmupRequestBody),
      });

      const warmupData = await warmupResponse.json();
      console.log('[CacheManagement] Warmup response:', warmupData);

      if (warmupResponse.ok) {
        setMessage(`âœ… å®Œäº†: ${warmupData.warmedUp}ãƒšãƒ¼ã‚¸ã‚’äº‹å‰èª­ã¿è¾¼ã¿ã—ã¾ã—ãŸ`);
        if (warmupData.failed > 0) {
          setMessage(prev => `${prev} (å¤±æ•—: ${warmupData.failed}ãƒšãƒ¼ã‚¸)`);
        }
        
        // Debug info
        if (warmupData.debug) {
          console.log('[CacheManagement] Warmup debug info:', warmupData.debug);
        }
      } else {
        setMessage(`âŒ ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: ${warmupData.error}`);
      }
      
      // çµ±è¨ˆã‚’æ›´æ–°
      setTimeout(fetchStats, 1000);
      
    } catch (error) {
      setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—
  const handleWarmupCache = async () => {
    setLoading(true);
    setMessage('');

    try {
      const token = getAuthToken();
      
      // ã¾ãšç¾åœ¨ã®ãƒšãƒ¼ã‚¸ãƒªã‚¹ãƒˆã‚’å–å¾—
      console.log('[CacheManagement] Getting page list before warmup...');
      const pagesResponse = await fetch('/api/cache-get-pages');
      
      let pageIds: string[] = [];
      if (pagesResponse.ok) {
        const pagesData = await pagesResponse.json();
        pageIds = pagesData.pageIds || [];
        console.log(`[CacheManagement] Retrieved ${pageIds.length} page IDs`);
      } else {
        console.log('[CacheManagement] Failed to get page list, using fallback');
      }

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
      const response = await fetch('/api/cache-warmup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          pageIds: pageIds.length > 0 ? pageIds : undefined,
          skipSiteMap: pageIds.length > 0
        }),
      });

      const data = await response.json();

      if (response.ok) {
        setMessage(`âœ… ${data.warmedUp}ãƒšãƒ¼ã‚¸ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’äº‹å‰èª­ã¿è¾¼ã¿ã—ã¾ã—ãŸ`);
        if (data.failed > 0) {
          setMessage(prev => `${prev} (å¤±æ•—: ${data.failed}ãƒšãƒ¼ã‚¸)`);
        }
      } else {
        setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${data.error}`);
      }
    } catch (error) {
      setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  // ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
  const handleClearPattern = async () => {
    const pattern = prompt('ã‚¯ãƒªã‚¢ã™ã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: notion:page:*ï¼‰');
    if (!pattern) return;

    setLoading(true);
    setMessage('');

    try {
      const token = getAuthToken();
      
      const response = await fetch('/api/cache-clear', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ type: 'pattern', pattern }),
      });

      const data = await response.json();

      if (response.ok) {
        setMessage(`âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³ "${pattern}" ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ`);
        setTimeout(fetchStats, 1000);
      } else {
        setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${data.error}`);
      }
    } catch (error) {
      setMessage(`âŒ ã‚¨ãƒ©ãƒ¼: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.container}>
      <h2>ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†</h2>
      
      {/* WebSocketæ¥ç¶šçŠ¶æ…‹ */}
      <div className={styles.status}>
        <div className={styles.statusItem}>
          <span>WebSocketæ¥ç¶š:</span>
          <span className={isConnected ? styles.connected : styles.disconnected}>
            {isConnected ? 'æ¥ç¶šä¸­' : 'åˆ‡æ–­'}
          </span>
        </div>
        {lastUpdate && (
          <div className={styles.statusItem}>
            <span>æœ€çµ‚æ›´æ–°:</span>
            <span>{lastUpdate.toLocaleString('ja-JP')}</span>
          </div>
        )}
      </div>

      {/* ã‚­ãƒ£ãƒƒã‚·ãƒ¥çµ±è¨ˆ */}
      {stats && (
        <div className={styles.stats}>
          <h3>ã‚­ãƒ£ãƒƒã‚·ãƒ¥çµ±è¨ˆ</h3>
          
          <div className={styles.statsSection}>
            <h4>ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥</h4>
            <ul>
              <li>ã‚¨ãƒ³ãƒˆãƒªæ•°: {stats.memory.size}</li>
              <li>ã‚µã‚¤ã‚º: {(stats.memory.calculatedSize / 1024 / 1024).toFixed(2)} MB</li>
              <li>ãƒ’ãƒƒãƒˆç‡: {stats.memory.hits > 0 ? ((stats.memory.hits / (stats.memory.hits + stats.memory.misses)) * 100).toFixed(1) : 0}%</li>
            </ul>
          </div>

          {stats.redis.connected && (
            <div className={styles.statsSection}>
              <h4>Redisã‚­ãƒ£ãƒƒã‚·ãƒ¥</h4>
              <ul>
                <li>çŠ¶æ…‹: æ¥ç¶šä¸­</li>
                <li>ã‚­ãƒ¼æ•°: {stats.redis.keyCount}</li>
                <li>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: {(stats.redis.memoryUsage / 1024 / 1024).toFixed(2)} MB</li>
              </ul>
            </div>
          )}
        </div>
      )}

      {/* ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ */}
      <div className={styles.actions}>
        <h3>ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢</h3>
        
        <div className={styles.buttons}>
          <button
            onClick={() => handleClearCache('all')}
            disabled={loading}
            className={styles.button}
            title="è­¦å‘Š: ã™ã¹ã¦ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ã¨ã€æ¬¡å›ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«èª­ã¿è¾¼ã¿ãŒé…ããªã‚Šã¾ã™"
          >
            ã™ã¹ã¦ã‚¯ãƒªã‚¢ âš ï¸
          </button>
          
          <button
            onClick={() => handleClearCache('notion')}
            disabled={loading}
            className={styles.button}
          >
            Notionã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
          </button>
          
          <button
            onClick={handleClearPattern}
            disabled={loading}
            className={styles.button}
          >
            ãƒ‘ã‚¿ãƒ¼ãƒ³æŒ‡å®šã‚¯ãƒªã‚¢
          </button>
          
          <button
            onClick={clearCache}
            disabled={loading}
            className={styles.button}
          >
            ãƒ–ãƒ©ã‚¦ã‚¶ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
          </button>
          
          <button
            onClick={handleWarmupCache}
            disabled={loading}
            className={styles.button}
            style={{ background: '#10b981' }}
          >
            ã‚­ãƒ£ãƒƒã‚·ãƒ¥äº‹å‰èª­ã¿è¾¼ã¿ ğŸš€
          </button>
          
          <button
            onClick={handleClearAndWarmup}
            disabled={loading}
            className={styles.button}
            style={{ background: '#6366f1' }}
            title="ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã™ãã«äº‹å‰èª­ã¿è¾¼ã¿ã‚’å®Ÿè¡Œ"
          >
            ã‚¯ãƒªã‚¢&ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ— ğŸ”„
          </button>
        </div>
      </div>

      {/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º */}
      {message && (
        <div className={styles.message}>
          {message}
        </div>
      )}

      {/* ä½¿ç”¨æ–¹æ³• */}
      <div className={styles.help}>
        <h3>ä½¿ç”¨æ–¹æ³•</h3>
        <ul>
          <li><strong>ã™ã¹ã¦ã‚¯ãƒªã‚¢</strong>: ãƒ¡ãƒ¢ãƒªã¨Redisã®å…¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢</li>
          <li><strong>Notionã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢</strong>: Notioné–¢é€£ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã¿ã‚¯ãƒªã‚¢</li>
          <li><strong>ãƒ‘ã‚¿ãƒ¼ãƒ³æŒ‡å®šã‚¯ãƒªã‚¢</strong>: ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ä¸€è‡´ã™ã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢</li>
          <li><strong>ãƒ–ãƒ©ã‚¦ã‚¶ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢</strong>: Service Workerã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢</li>
        </ul>
        
        <h4>Webhookã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ</h4>
        <p>å¤–éƒ¨ã‹ã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹å ´åˆ:</p>
        <pre className={styles.code}>
{`curl -X POST ${process.env.NEXT_PUBLIC_SITE_URL}/api/cache-clear \\
  -H "Authorization: Bearer YOUR_TOKEN" \\
  -H "Content-Type: application/json" \\
  -d '{"type": "all"}'`}
        </pre>
        
        <h4>Notion Webhookè¨­å®š</h4>
        <p>Notionã‹ã‚‰ã®è‡ªå‹•æ›´æ–°ã‚’å—ã‘å–ã‚‹å ´åˆ:</p>
        <pre className={styles.code}>
{`Webhook URL: ${process.env.NEXT_PUBLIC_SITE_URL}/api/webhook/notion-update
Secret: NOTION_WEBHOOK_SECRETç’°å¢ƒå¤‰æ•°ã«è¨­å®š`}
        </pre>
      </div>
    </div>
  );
};